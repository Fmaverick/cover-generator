<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>小红书图文生成系统 (Pro)</title>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <!-- 引入字体 -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700;900&family=Noto+Serif+SC:wght@400;600;700;900&display=swap" rel="stylesheet">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['"Noto Sans SC"', 'system-ui', 'sans-serif'],
                        serif: ['"Noto Serif SC"', 'Georgia', 'serif'],
                    }
                }
            }
        }
    </script>

    <style>
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        body { background-color: #f5f5f5; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback, useMemo } = React;

        // --- 图标组件 ---
        const IconBase = ({ children, size = 20, className = "", ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>
        );
        const Download = (p) => <IconBase {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></IconBase>;
        const ImageI = (p) => <IconBase {...p}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></IconBase>;
        const Trash = (p) => <IconBase {...p}><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></IconBase>;

        // --- 核心配置 ---
        const CONFIG = {
            width: 1080,
            height: 1920,
            safeMargin: 0.1, // 10%
            templates: [
                { id: 'ins', name: 'INS 风语录', desc: '梦幻光斑，半透明卡片' }, // 新增
                { id: 'memo', name: '备忘录', desc: '仿iOS风格，黄色高亮' }, 
                { id: 'article', name: '深度好文', desc: '封面含正文，左对齐，适合长文' }, 
                { id: 'book', name: '古籍书页', desc: '宋体排版，自动分页，居中标题' },
                { id: 'notes', name: '纯净笔记', desc: '极简风格，重点突出' },
                { id: 'poster', name: '封面海报', desc: '单页模式，适合标题' },
            ]
        };

        // --- 核心文本处理：计算所有折行 ---
        // 返回 [{tokens:[], width:0}, ...]
        const calculateWrappedLines = (ctx, text, maxWidth, fontSize, fontFamily, isBold = false) => {
            const allLines = [];
            const paragraphs = text.split('\n');

            // 设置字体用于测量
            ctx.font = `${isBold ? '900' : '500'} ${fontSize}px ${fontFamily}`;

            paragraphs.forEach(para => {
                if (!para.trim()) {
                    allLines.push({ tokens: [], width: 0, isEmpty: true }); // 空行标记
                    return;
                }

                // Token 解析
                const tokens = [];
                const regex = /\[(.*?)\]/g;
                let lastIndex = 0;
                let match;
                while ((match = regex.exec(para)) !== null) {
                    if (match.index > lastIndex) tokens.push({ text: para.substring(lastIndex, match.index), highlight: false });
                    tokens.push({ text: match[1], highlight: true });
                    lastIndex = regex.lastIndex;
                }
                if (lastIndex < para.length) tokens.push({ text: para.substring(lastIndex), highlight: false });
                if (tokens.length === 0) tokens.push({ text: para, highlight: false });

                // 逐行计算
                let currentLineTokens = [];
                let currentLineWidth = 0;

                tokens.forEach(token => {
                    const chars = token.text.split('');
                    chars.forEach(char => {
                        ctx.font = `${token.highlight ? '900' : (isBold ? '900' : '500')} ${fontSize}px ${fontFamily}`;
                        const charWidth = ctx.measureText(char).width;

                        if (currentLineWidth + charWidth > maxWidth) {
                            allLines.push({ tokens: currentLineTokens, width: currentLineWidth });
                            currentLineTokens = [];
                            currentLineWidth = 0;
                        }
                        currentLineTokens.push({ char, highlight: token.highlight, width: charWidth });
                        currentLineWidth += charWidth;
                    });
                });

                if (currentLineTokens.length > 0) {
                    allLines.push({ tokens: currentLineTokens, width: currentLineWidth });
                }
            });
            return allLines;
        };

        // --- 兼容性工具函数：绘制圆角矩形 ---
        const drawRoundRectPath = (ctx, x, y, w, h, r) => {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        };

        // --- Error Boundary ---
        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null };
            }
            static getDerivedStateFromError(error) {
                return { hasError: true, error };
            }
            componentDidCatch(error, errorInfo) {
                console.error("Uncaught error:", error, errorInfo);
            }
            render() {
                if (this.state.hasError) {
                    return (
                        <div className="p-8 text-red-600 bg-red-50">
                            <h1 className="text-2xl font-bold">Something went wrong.</h1>
                            <pre className="mt-4 p-4 bg-white rounded border border-red-200 overflow-auto">
                                {this.state.error && this.state.error.toString()}
                            </pre>
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        const App = () => {
            const [title, setTitle] = useState("经历过异常体验的女性怎样\n知道自己的心理健康和\n神经系统到底有多偏离？");
            const [content, setContent] = useState("这是一个非常深刻且具有实操性的问题。对于经历过“[异常体验]”（如政治迫害、大规模网暴、冤假错案、系统性背叛）的高智商女性来说，常规的心理健康标准已经失效了。\n\n你的神经系统为了在极端环境中生存，已经进行了“[军事化重组]”。你不能用“和平年代”的标准来衡量一个刚从“战场”归来的人。\n\n以下是如何科学评估自身状态、寻找同类以及重建生产力的三部曲：\n\n一、评估偏差：如何量化你的“[精神弹道]”偏离度\n\n不要依赖主观感受（因为你的感受可能已经解离），也不要完全依赖普通心理医生的量表。你需要关注生物指标和认知功能。\n\n1. 监测“[自主神经系统]”的生理底噪\n高智商人群擅长用理智压抑痛苦，但身体不会撒谎。");
            
            const [topTag, setTopTag] = useState('" AI Vibe coding 想创业'); // INS 顶部标签
            const [author, setAuthor] = useState('Francis'); // INS 作者
            const [date, setDate] = useState('2025-12-30'); // INS 日期
            
            const [images, setImages] = useState([]);
            const [template, setTemplate] = useState('article'); // 默认 Article
            const [bgColor, setBgColor] = useState('#FFFFFF');
            const [textColor, setTextColor] = useState('#000000');
            const [highlightColor, setHighlightColor] = useState('#000000'); // Article 默认黑/红
            const [fontSizeScale, setFontSizeScale] = useState(1);
            
            const [pagesData, setPagesData] = useState([]);
            const [isGenerating, setIsGenerating] = useState(false);
            
            const canvasRef = useRef(null);
            const fileInputRef = useRef(null);

            // --- 自动切换模版配色 ---
            useEffect(() => {
                if (template === 'book') {
                    setBgColor('#F9F7F1'); setTextColor('#2C2C2C'); setHighlightColor('#8B0000');
                } else if (template === 'notes') {
                    setBgColor('#FFFFFF'); setTextColor('#333333'); setHighlightColor('#FF2442');
                } else if (template === 'poster') {
                    setBgColor('#F5F5F5'); setTextColor('#000000'); setHighlightColor('#FF0000');
                } else if (template === 'article') {
                    setBgColor('#FFFFFF'); setTextColor('#000000'); setHighlightColor('#D32F2F');
                } else if (template === 'memo') {
                    setBgColor('#FFFFFF'); setTextColor('#000000'); setHighlightColor('#FDE047'); // 备忘录黄
                } else if (template === 'ins') {
                    setBgColor('#FFFFFF'); setTextColor('#1F1F1F'); setHighlightColor('#000000'); // INS 默认黑字
                }
            }, [template]);

            // --- 核心：分页逻辑 ---
            useEffect(() => {
                if (!canvasRef.current) return;
                const ctx = canvasRef.current.getContext('2d');
                const { width, height, safeMargin } = CONFIG;
                const marginX = width * safeMargin;
                const marginY = height * safeMargin;
                const safeWidth = width - (marginX * 2);
                const safeHeight = height - (marginY * 2);

                const fontFamily = (template === 'book' || template === 'article') ? '"Noto Serif SC", serif' : '"Noto Sans SC", sans-serif';
                const baseBodySize = (template === 'book' ? 48 : 42) * fontSizeScale;
                const lineHeight = baseBodySize * (template === 'book' ? 1.8 : 1.6);

                // 1. 预计算封面标题 (所有模版通用，确保自动折行)
                const titleSize = (template === 'book' ? 120 : 100) * fontSizeScale;
                const titleFontFamily = (template === 'book' || template === 'article') ? '"Noto Serif SC", serif' : '"Noto Sans SC", sans-serif';
                const titleLines = calculateWrappedLines(ctx, title, safeWidth, titleSize, titleFontFamily, true);

                // 2. 计算所有正文行
                const allLines = calculateWrappedLines(ctx, content, safeWidth, baseBodySize, fontFamily);

                let pages = [];
                let remainingLines = [...allLines];
                // 安全退出：防止死循环
                const MAX_PAGES = 50; 
                let loopCount = 0;

                if (template === 'article' || template === 'memo') {
                    // Article & Memo 模式：首页 = 标题 + 正文
                    
                    const titleHeight = titleLines.length * (titleSize * 1.3) + 60; // 标题总高 + 间距
                    
                    // B. 首页可用正文高度
                    let firstPageBodyHeight = safeHeight - titleHeight;
                    
                    // Memo Header 占用空间
                    if (template === 'memo') {
                        // Header height 约 100 + margin
                        firstPageBodyHeight -= 100;
                    }
                    
                    // C. 填充首页正文
                    let firstPageLines = [];
                    let currentH = 0;
                    
                    while (remainingLines.length > 0) {
                        const line = remainingLines[0];
                        const h = line.isEmpty ? lineHeight * 0.5 : lineHeight;
                        if (currentH + h > firstPageBodyHeight) break;
                        firstPageLines.push(remainingLines.shift());
                        currentH += h;
                    }

                    pages.push({
                        type: 'mixed', // 混合页
                        titleLines: titleLines, // 使用预计算好的标题行
                        lines: firstPageLines,
                        pageIndex: 1,
                        bgImage: images[0] || null
                    });

                } else if (template === 'poster') {
                    // Poster: 只有一张封面，但带标题
                    pages.push({ type: 'cover', titleLines: titleLines, bgImage: images[0] || null });
                    setPagesData(pages);
                    return; // 结束
                } else if (template === 'ins') {
                    // INS: 封面
                    pages.push({ type: 'cover', title: title, titleLines: titleLines, bgImage: images[0] || null });
                } else {
                    // Book / Notes: 首页是纯封面，带标题
                    pages.push({ type: 'cover', titleLines: titleLines, bgImage: images[0] || null });
                }

                // 处理剩余正文 (生成 Content Pages)
                let currentPageLines = [];
                let currentY = 0;

                while (remainingLines.length > 0) {
                    if (loopCount++ > 5000) break; // 防止无限循环

                    const line = remainingLines.shift();
                    const h = line.isEmpty ? lineHeight * 0.5 : lineHeight;

                    if (currentY + h > safeHeight - 100) { // 减去页码高度
                        pages.push({
                            type: 'content',
                            lines: currentPageLines,
                            pageIndex: pages.length + 1,
                            bgImage: images.length > 0 ? images[(pages.length) % images.length] : null
                        });
                        currentPageLines = [];
                        currentY = 0;
                        if (pages.length > MAX_PAGES) break; // 超过页数限制
                    }
                    
                    currentPageLines.push(line);
                    currentY += h;
                }

                if (currentPageLines.length > 0) {
                    pages.push({
                        type: 'content',
                        lines: currentPageLines,
                        pageIndex: pages.length + 1,
                        bgImage: images.length > 0 ? images[(pages.length) % images.length] : null
                    });
                }

                setPagesData(pages);

            }, [title, content, template, fontSizeScale, images, topTag, author, date]); // 添加依赖

            // --- 绘制 Memo 顶部导航栏 ---
            const drawMemoHeader = (ctx, width, height) => {
                const iconColor = '#EAB308'; // Yellow-500
                const y = height * 0.06;
                const x = width * 0.06;
                
                ctx.save();
                
                // 1. 返回箭头 <
                ctx.beginPath();
                ctx.lineWidth = 6;
                ctx.strokeStyle = iconColor;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.moveTo(x + 25, y);
                ctx.lineTo(x, y + 25);
                ctx.lineTo(x + 25, y + 50);
                ctx.stroke();

                // 2. "备忘录" 文字
                ctx.font = 'bold 42px "Noto Sans SC", sans-serif';
                ctx.fillStyle = iconColor;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText("备忘录", x + 40, y + 25);

                // 3. 右侧图标 (分享 + 更多)
                const rx = width - x;
                
                // 更多 (圆圈 + 三点)
                ctx.beginPath();
                ctx.arc(rx - 25, y + 25, 24, 0, Math.PI * 2);
                ctx.strokeStyle = iconColor;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.fillStyle = iconColor;
                ctx.beginPath(); ctx.arc(rx - 38, y + 25, 3, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(rx - 25, y + 25, 3, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(rx - 12, y + 25, 3, 0, Math.PI * 2); ctx.fill();

                // 分享 (方框 + 箭头)
                const sx = rx - 100;
                ctx.beginPath();
                ctx.rect(sx - 20, y + 10, 40, 40);
                ctx.strokeStyle = iconColor;
                ctx.stroke();
                // 箭头
                ctx.beginPath();
                ctx.moveTo(sx, y + 30);
                ctx.lineTo(sx, y - 10);
                ctx.lineTo(sx - 10, y + 5);
                ctx.moveTo(sx, y - 10);
                ctx.lineTo(sx + 10, y + 5);
                ctx.stroke();

                ctx.restore();
                return y + 100; // 返回 Header 结束位置
            };

            // --- 绘制 INS 梦幻光斑背景 ---
            const drawInsBackground = (ctx, width, height) => {
                // 1. 基础柔和渐变
                const grd = ctx.createLinearGradient(0, 0, width, height);
                grd.addColorStop(0, '#E0F2FE'); // Pale Blue
                grd.addColorStop(0.5, '#F0F9FF');
                grd.addColorStop(1, '#DBEAFE');
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, width, height);

                // 2. 绘制模糊光斑 (使用径向渐变模拟模糊，避免 filter 崩溃)
                const drawOrb = (x, y, r, color) => {
                    ctx.save();
                    ctx.globalAlpha = 0.4;
                    // 不使用 ctx.filter = 'blur(...)'; 兼容性差
                    const grd = ctx.createRadialGradient(x, y, 0, x, y, r);
                    grd.addColorStop(0, color);
                    grd.addColorStop(1, 'rgba(255,255,255,0)'); // 淡出到透明
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                };

                drawOrb(width * 0.2, height * 0.2, 300, '#A5F3FC'); // Cyan
                drawOrb(width * 0.8, height * 0.3, 400, '#E879F9'); // Purple/Pink
                drawOrb(width * 0.5, height * 0.8, 350, '#818CF8'); // Blue/Indigo
                drawOrb(width * 0.1, height * 0.9, 250, '#F472B6'); // Pink

                // 3. 添加暗角 (Vignette)
                const radial = ctx.createRadialGradient(width/2, height/2, width*0.3, width/2, height/2, width);
                radial.addColorStop(0, 'rgba(255,255,255,0)');
                radial.addColorStop(1, 'rgba(255,255,255,0.6)');
                ctx.fillStyle = radial;
                ctx.fillRect(0, 0, width, height);
            };

            // --- 渲染单个页面 ---
            // 提取渲染逻辑以便复用
            const renderLogic = (canvas, pageData, totalPages) => {
                 const ctx = canvas.getContext('2d');
                 const { width, height, safeMargin } = CONFIG;
                 const marginX = width * safeMargin;
                 const marginY = height * safeMargin;
                 const fontFamily = (template === 'book' || template === 'article') ? '"Noto Serif SC", serif' : '"Noto Sans SC", sans-serif';

                 // 1. 背景处理
                 if (template === 'ins') {
                     drawInsBackground(ctx, width, height);
                 } else {
                     ctx.fillStyle = bgColor;
                     ctx.fillRect(0, 0, width, height);
                 }

                 // Memo Header
                 let contentStartY = marginY;
                 if (template === 'memo') {
                     contentStartY = drawMemoHeader(ctx, width, height);
                 }

                 if (template === 'book') { // 纸纹
                     ctx.save();
                     ctx.globalAlpha = 0.08;
                     ctx.fillStyle = '#000000';
                     for (let i = 0; i < 3000; i++) {
                         ctx.beginPath(); ctx.arc(Math.random()*width, Math.random()*height, Math.random()*1.5, 0, Math.PI*2); ctx.fill();
                     }
                     ctx.restore();
                 }

                 // 背景图/插图
                 if (pageData.bgImage && pageData.bgImage.src) {
                     ctx.save();
                     ctx.globalAlpha = 0.08; // 淡淡的水印
                     const img = pageData.bgImage.src;
                     const scale = Math.max(width/img.width, height/img.height);
                     ctx.drawImage(img, (width - img.width*scale)/2, (height - img.height*scale)/2, img.width*scale, img.height*scale);
                     ctx.restore();
                 }

                 ctx.fillStyle = textColor;
                 ctx.textBaseline = 'top';

                 // --- 渲染不同类型 ---
                 if (pageData.type === 'cover' && template === 'ins') {
                     // INS 封面：磨砂卡片 + 引用语
                     
                     // 1. 绘制磨砂玻璃卡片
                     const cardW = width * 0.85;
                     const cardH = height * 0.6;
                     const cardX = (width - cardW) / 2;
                     const cardY = (height - cardH) / 2;
                     
                     ctx.save();
                     // 卡片阴影
                     ctx.shadowColor = 'rgba(0,0,0,0.1)';
                     ctx.shadowBlur = 40;
                     ctx.shadowOffsetY = 20;
                     
                     // 卡片背景 (半透明白)
                     ctx.fillStyle = 'rgba(255, 255, 255, 0.75)';
                     drawRoundRectPath(ctx, cardX, cardY, cardW, cardH, 40);
                     ctx.fill();
                     
                     // 边框
                     ctx.lineWidth = 2;
                     ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                     ctx.stroke();
                     ctx.restore();

                     // 2. 卡片内容
                     // Top Tag (Right Aligned)
                     ctx.font = `italic 400 ${36 * fontSizeScale}px "Georgia", serif`; // 减轻字重和字号
                     ctx.fillStyle = '#9AA0A6';
                     ctx.textAlign = 'right';
                     ctx.fillText(`" ${topTag}`, cardX + cardW - 60, cardY + 100);

                     // Main Quote (Left Aligned, Big Serif)
                     const quoteSize = 72 * fontSizeScale; 
                     ctx.font = `700 ${quoteSize}px "Noto Serif SC", serif`; // 回归宋体，字重700
                     ctx.fillStyle = '#1F1F1F';
                     ctx.textAlign = 'left';
                     
                     // 简单折行引用语 (使用 title 字段)
                     const quoteWords = pageData.title.split(''); 
                     let line = '“'; 
                     let qX = cardX + 60;
                     let qY = cardY + cardH * 0.35;
                     
                     // 简单处理标题换行
                     const tLines = [];
                     let tempLine = '“';
                     for (let char of pageData.title) {
                         if (ctx.measureText(tempLine + char).width > cardW - 120) {
                             tLines.push(tempLine);
                             tempLine = char;
                         } else {
                             tempLine += char;
                         }
                     }
                     tLines.push(tempLine + '”');

                     tLines.forEach(l => {
                         ctx.fillText(l, qX, qY);
                         qY += quoteSize * 1.5; 
                     });

                     // Divider
                     ctx.beginPath();
                     ctx.strokeStyle = '#F3F4F6'; // 更淡的分割线
                     ctx.lineWidth = 1; // 更细
                     ctx.moveTo(cardX + 60, cardY + cardH - 140);
                     ctx.lineTo(cardX + cardW - 60, cardY + cardH - 140);
                     ctx.stroke();

                     // Footer (Icon + Site + Date)
                     const footerY = cardY + cardH - 100;
                     
                     // Icon
                     ctx.fillStyle = '#1F1F1F'; // 稍微淡一点的黑
                     drawRoundRectPath(ctx, cardX + 60, footerY, 50, 50, 12);
                     ctx.fill();
                     // Star glyph
                     ctx.fillStyle = '#FFFFFF';
                     ctx.font = '30px sans-serif';
                     ctx.textAlign = 'center';
                     ctx.textBaseline = 'middle';
                     ctx.fillText('✦', cardX + 85, footerY + 28);

                     // Site Name
                     ctx.font = `400 32px "Noto Serif SC", serif`; // 字重降为 400
                     ctx.fillStyle = '#9CA3AF'; // 更淡的灰
                     ctx.textAlign = 'left';
                     ctx.fillText('Metasight.cloud', cardX + 130, footerY + 25);

                     // Date & Author
                     ctx.font = `400 30px "Noto Serif SC", serif`; // 字重降为 400
                     ctx.fillStyle = '#D1D5DB'; // 很淡的灰
                     ctx.textAlign = 'right';
                     ctx.fillText(`${date} by ${author}`, cardX + cardW - 60, footerY + 25);
                     
                     ctx.textBaseline = 'top'; // Reset

                 } else if (pageData.type === 'cover') {
                     // 纯封面 (居中，但 Memo 模式左对齐)
                     const titleSize = (template === 'book' ? 120 : 100) * fontSizeScale;
                     ctx.font = `900 ${titleSize}px ${fontFamily}`;
                     
                     let curY = template === 'memo' ? contentStartY + 60 : (template === 'poster' ? height * 0.15 : height * 0.3);

                     // 使用预计算的 titleLines 进行绘制
                     pageData.titleLines.forEach(lineObj => {
                         // 计算该行总宽以居中 (Memo 左对齐)
                         let lineWidth = lineObj.width;
                         if (lineWidth === undefined) {
                             lineWidth = lineObj.tokens.reduce((acc, t) => acc + t.width, 0);
                         }
                         
                         let curX = template === 'memo' ? marginX : (width - lineWidth) / 2;
                         
                         lineObj.tokens.forEach(token => {
                             // Memo 标题字重优化
                             const fontWeight = (template === 'memo') ? '700' : '900';
                             ctx.font = `${fontWeight} ${titleSize}px ${fontFamily}`;
                             
                             // 高亮处理
                             if (token.highlight && template === 'memo') {
                                 // Memo 高亮：背景色块
                                 ctx.save();
                                 ctx.fillStyle = highlightColor; // 黄色背景
                                 ctx.fillRect(curX, curY, token.width, titleSize * 1.1);
                                 ctx.restore();
                                 ctx.fillStyle = '#000000'; // 文字保持黑
                             } else {
                                 ctx.fillStyle = token.highlight ? highlightColor : textColor;
                             }
                             
                             ctx.fillText(token.char, curX, curY);
                             curX += token.width;
                         });
                         
                         curY += titleSize * 1.3;
                     });

                     if (template !== 'memo') {
                         ctx.font = `500 ${40 * fontSizeScale}px ${fontFamily}`;
                         ctx.fillStyle = highlightColor;
                         ctx.textAlign = 'center'; 
                         ctx.fillText("--- 左滑查看更多 ---", width/2, height - marginY - 100);
                     }
                 } else if (pageData.type === 'mixed') {
                     // 混合页 (Article / Memo 首页: 标题 + 正文)
                     // A. 标题 (左对齐)
                     const titleSize = 100 * fontSizeScale;
                     let curY = marginY;
                     
                     if (template === 'memo') {
                         curY = contentStartY + 40; // Memo 首页标题起始位置
                     }
                     
                     ctx.textAlign = 'left';
                     // 遍历预计算的 titleLines
                     pageData.titleLines.forEach(lineObj => {
                         let curX = marginX;
                         lineObj.tokens.forEach(token => {
                             const fontWeight = (template === 'memo') ? '700' : '900';
                             ctx.font = `${fontWeight} ${titleSize}px ${fontFamily}`;
                             
                             // 高亮处理 (Memo 标题)
                             if (token.highlight && template === 'memo') {
                                 ctx.save();
                                 ctx.fillStyle = highlightColor; 
                                 ctx.fillRect(curX, curY, token.width, titleSize * 1.1);
                                 ctx.restore();
                                 ctx.fillStyle = '#000000';
                             } else {
                                 ctx.fillStyle = textColor;
                             }
                             
                             ctx.fillText(token.char, curX, curY);
                             curX += token.width;
                         });
                         curY += titleSize * 1.3;
                     });

                     curY += 60; // 标题与正文间距

                     // B. 正文 (左对齐)
                     const bodySize = 42 * fontSizeScale;
                     const lineHeight = bodySize * (template === 'memo' ? 1.8 : 1.6); // Memo 行距稍大

                     pageData.lines.forEach(line => {
                         if (line.isEmpty) { curY += lineHeight * 0.5; return; }
                         let curX = marginX;
                         line.tokens.forEach(token => {
                             // Memo 正文字重优化
                             const fontWeight = (template === 'memo') ? '400' : (token.highlight ? '900' : '500');
                             ctx.font = `${fontWeight} ${bodySize}px ${fontFamily}`;
                             
                             if (token.highlight && template === 'memo') {
                                 ctx.save();
                                 ctx.fillStyle = highlightColor;
                                 ctx.fillRect(curX, curY + 5, token.width, bodySize * 1.0); // 微调色块位置
                                 ctx.restore();
                                 ctx.fillStyle = '#000000';
                             } else {
                                 ctx.fillStyle = token.highlight ? highlightColor : textColor;
                             }
                             
                             ctx.fillText(token.char, curX, curY);
                             curX += token.width;
                         });
                         curY += lineHeight;
                     });

                     // 页码
                     if (template === 'memo') {
                         ctx.font = `400 32px ${fontFamily}`;
                         ctx.fillStyle = '#999999';
                         ctx.textAlign = 'center';
                         ctx.fillText(`- ${pageData.pageIndex} / ${totalPages} -`, width/2, height - marginY + 20);
                     } else {
                         // Article 页码
                         ctx.font = `400 32px ${fontFamily}`;
                         ctx.fillStyle = '#999999';
                         ctx.textAlign = 'center';
                         ctx.fillText(`- ${pageData.pageIndex} / ${totalPages} -`, width/2, height - marginY + 20);
                     }

                 } else if (pageData.type === 'content') {
                     // 纯内容页
                     const bodySize = (template === 'book' ? 48 : 42) * fontSizeScale;
                     const lineHeight = bodySize * (template === 'book' ? 1.8 : 1.6);
                     let curY = marginY;

                     // Memo 模式，内容页也需要 Header
                     if (template === 'memo') {
                         curY = contentStartY + 40;
                     }
                     
                     ctx.textAlign = 'left';
                     pageData.lines.forEach(line => {
                         if (line.isEmpty) { curY += bodySize * 0.8; return; }
                         let curX = marginX;
                         line.tokens.forEach(token => {
                             // Memo 正文字重优化 (Content Page)
                             const fontWeight = (template === 'memo') ? '400' : (token.highlight ? '900' : '500');
                             ctx.font = `${fontWeight} ${bodySize}px ${fontFamily}`;
                             
                             // 高亮处理
                             if (token.highlight && template === 'memo') {
                                 // Memo 高亮：背景色块
                                 ctx.save();
                                 ctx.fillStyle = highlightColor; // 黄色背景
                                 ctx.fillRect(curX, curY, token.width, bodySize * 1.1);
                                 ctx.restore();
                                 ctx.fillStyle = '#000000'; // 文字保持黑
                             } else {
                                 ctx.fillStyle = token.highlight ? highlightColor : textColor;
                             }

                             ctx.fillText(token.char, curX, curY);
                             curX += token.width;
                         });
                         curY += lineHeight;
                     });

                     // 页码
                     ctx.font = `400 32px ${fontFamily}`;
                     ctx.fillStyle = '#999999';
                     ctx.textAlign = 'center';
                     ctx.fillText(`- ${pageData.pageIndex} / ${totalPages} -`, width/2, height - marginY + 20);
                 }
            };

            const handleBatchDownload = async () => {
                setIsGenerating(true);
                const zip = new JSZip();
                const folder = zip.folder("xhs_posts");
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = CONFIG.width;
                tempCanvas.height = CONFIG.height;

                try {
                    for (let i = 0; i < pagesData.length; i++) {
                        renderLogic(tempCanvas, pagesData[i], pagesData.length);
                        const blob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/png'));
                        folder.file(`${i+1}.png`, blob);
                    }
                    const content = await zip.generateAsync({ type: "blob" });
                    saveAs(content, "小红书图文_全套.zip");
                } catch(e) { alert(e.message); } 
                finally { setIsGenerating(false); }
            };

            const handleFileUpload = (e) => {
                const files = Array.from(e.target.files);
                if (!files.length) return;
                files.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const img = new Image();
                        img.onload = () => setImages(prev => [...prev, { id: Date.now(), src: img, url: ev.target.result }]);
                        img.src = ev.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            };

            return (
                <div className="flex flex-col h-screen max-w-[1600px] mx-auto md:flex-row">
                    <canvas ref={canvasRef} width={CONFIG.width} height={CONFIG.height} className="hidden" />
                    
                    {/* 左侧控制 */}
                    <div className="flex flex-col w-full p-6 space-y-6 overflow-y-auto bg-white border-r border-gray-200 md:w-1/3 scrollbar-hide">
                        <div>
                            <h1 className="text-2xl font-black text-gray-900">图文生成系统 Pro</h1>
                            <p className="text-xs text-gray-500">自动分页 · 风格统一 · 批量导出</p>
                        </div>
                        <div className="grid grid-cols-2 gap-2">
                            {CONFIG.templates.map(t => (
                                <button key={t.id} onClick={() => setTemplate(t.id)} 
                                    className={`p-3 border rounded-xl text-left transition-all ${template === t.id ? 'bg-gray-900 text-white ring-2 ring-gray-900' : 'hover:bg-gray-50 text-gray-600'}`}>
                                    <div className="text-sm font-bold">{t.name}</div>
                                    <div className="text-[10px] opacity-60 truncate">{t.desc}</div>
                                </button>
                            ))}
                        </div>
                        <div className="space-y-4">
                            <div>
                                <label className="text-xs font-bold text-gray-500">封面标题</label>
                                <textarea value={title} onChange={e => setTitle(e.target.value)} className="w-full p-3 mt-1 font-bold border rounded-lg h-24 focus:ring-2 focus:ring-black outline-none" placeholder="输入标题..."></textarea>
                            </div>
                            <div>
                                <label className="text-xs font-bold text-gray-500">正文内容 (自动分页)</label>
                                <textarea value={content} onChange={e => setContent(e.target.value)} className="w-full p-3 mt-1 text-sm border rounded-lg h-64 focus:ring-2 focus:ring-black outline-none" placeholder="输入长文章..."></textarea>
                                <p className="mt-1 text-[10px] text-gray-400">已生成 {pagesData.length} 页</p>
                            </div>
                        </div>
                        {/* 图片上传简略... */}
                        <div className="grid grid-cols-2 gap-2 p-3 bg-gray-50 rounded-lg">
                            {template === 'ins' && (
                                <div className="col-span-2 space-y-2 mb-2">
                                    <div><span className="text-xs text-gray-500">顶部标签</span><input type="text" value={topTag} onChange={e => setTopTag(e.target.value)} className="block w-full h-8 mt-1 rounded border px-2 text-sm"/></div>
                                    <div className="grid grid-cols-2 gap-2">
                                        <div><span className="text-xs text-gray-500">作者</span><input type="text" value={author} onChange={e => setAuthor(e.target.value)} className="block w-full h-8 mt-1 rounded border px-2 text-sm"/></div>
                                        <div><span className="text-xs text-gray-500">日期</span><input type="text" value={date} onChange={e => setDate(e.target.value)} className="block w-full h-8 mt-1 rounded border px-2 text-sm"/></div>
                                    </div>
                                </div>
                            )}
                            <div><span className="text-xs text-gray-500">背景色</span><input type="color" value={bgColor} onChange={e => setBgColor(e.target.value)} className="block w-full h-6 mt-1 rounded cursor-pointer"/></div>
                            <div><span className="text-xs text-gray-500">文字色</span><input type="color" value={textColor} onChange={e => setTextColor(e.target.value)} className="block w-full h-6 mt-1 rounded cursor-pointer"/></div>
                            <div><span className="text-xs text-gray-500">高亮色</span><input type="color" value={highlightColor} onChange={e => setHighlightColor(e.target.value)} className="block w-full h-6 mt-1 rounded cursor-pointer"/></div>
                            <div><span className="text-xs text-gray-500">字号</span><input type="range" min="0.8" max="1.3" step="0.1" value={fontSizeScale} onChange={e => setFontSizeScale(Number(e.target.value))} className="block w-full h-6 mt-1"/></div>
                        </div>
                        <button onClick={handleBatchDownload} disabled={isGenerating} className="w-full py-4 mt-auto font-bold text-white transition-all bg-gray-900 rounded-xl hover:bg-black shadow-lg flex justify-center items-center gap-2">
                            {isGenerating ? '生成中...' : <><Download /> 导出全套 ({pagesData.length}张)</>}
                        </button>
                    </div>

                    {/* 右侧预览 */}
                    <div className="flex-1 overflow-x-auto bg-gray-100 p-8 flex items-center gap-8 snap-x">
                        {pagesData.map((page, idx) => (
                            <div key={idx} className="snap-center shrink-0 flex flex-col items-center gap-4">
                                <span className="text-sm font-bold text-gray-400">
                                    {page.type === 'cover' ? '封面' : (page.type === 'mixed' ? '封面 (正文)' : `第 ${page.pageIndex} 页`)}
                                </span>
                                <div className="w-[360px] aspect-[9/16] bg-white shadow-2xl rounded-2xl overflow-hidden ring-4 ring-white relative">
                                    <CanvasPreview 
                                        pageData={page} 
                                        width={CONFIG.width} 
                                        height={CONFIG.height} 
                                        template={template}
                                        bgColor={bgColor}
                                        textColor={textColor}
                                        highlightColor={highlightColor}
                                        fontSizeScale={fontSizeScale}
                                        totalPages={pagesData.length}
                                        renderLogic={renderLogic}
                                    />
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const CanvasPreview = ({ pageData, width, height, template, bgColor, textColor, highlightColor, fontSizeScale, totalPages, renderLogic }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                if (canvasRef.current) renderLogic(canvasRef.current, pageData, totalPages);
            }, [pageData, width, height, template, bgColor, textColor, highlightColor, fontSizeScale, totalPages, renderLogic]);
            return <canvas ref={canvasRef} width={width} height={height} className="w-full h-full object-contain" />;
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            <ErrorBoundary>
                <App />
            </ErrorBoundary>
        );
    </script>
</body>
</html>